<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="css/main.css">
    <style>
        #container {
            position: absolute;
            margin: 0px auto;
            width: 100vw;
            height: 100vh;
            border: 10px #333 solid;
        }

        #videoElement {
            width: 100vw;
            height: 100vh;
            background-color: #666;
        }

        canvas {
            position: absolute;
        }

        .video-options {
            position: absolute;
            left: 20px;
            top: 30px;
            z-index: 9999;
        }
    </style>
</head>

<body>
    <div class="video-options">
        <select name="" id="" class="custom-select">
            <option value="">Select camera</option>
        </select>
    </div>
    <div id="container">
        <video autoplay="true" id="videoElement">

        </video>
    </div>
    <script type="module">

        import * as THREE from '../build/three.module.js';
        import { DeviceOrientationControls } from './jsm/controls/DeviceOrientationControls.js';

        let camera, scene, renderer, controls;
        let mesh;
        let constraints = {
            video: true
        };

        init();
        animate();

        function init() {

            var video = document.querySelector("#videoElement");
            const cameraOptions = document.querySelector('.video-options>select');


            const startStream = async (constraints) => {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log("stream", stream);
                video.srcObject = stream;
            };

            // if (navigator.mediaDevices.getUserMedia) {
            // 	navigator.mediaDevices.getUserMedia({ video: true })
            // 		.then(function (stream) {
            // 			video.srcObject = stream;
            // 		})
            // 		.catch(function (err0r) {
            // 			console.log("Something went wrong!");
            // 		});
            // }

            const getCameraSelection = async () => {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const options = videoDevices.map(videoDevice => {
                    return `<option value="${videoDevice.deviceId}">${videoDevice.label}</option>`;
                });
                cameraOptions.innerHTML = options.join('');
            };

            getCameraSelection();

            cameraOptions.onchange = () => {
                const updatedConstraints = {
                    ...constraints,
                    deviceId: {
                        exact: cameraOptions.value
                    }
                };
                console.log("Updated constraints", updatedConstraints);
                startStream(updatedConstraints);
            };

            startStream(constraints);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;

            controls = new DeviceOrientationControls(camera);

            scene = new THREE.Scene();

            const texture = new THREE.TextureLoader().load('textures/crate.gif');

            const geometry = new THREE.BoxBufferGeometry(50, 50, 50);
            const material = new THREE.MeshBasicMaterial({ map: texture });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            //

            window.addEventListener('resize', onWindowResize, false);



        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            mesh.rotation.x += 0.005;
            mesh.rotation.y += 0.01;

            controls.update();

            renderer.render(scene, camera);

        }

    </script>

</body>

</html>