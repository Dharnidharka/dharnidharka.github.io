var midiPart, notes_arr;
var player = {}, genre = "TECHNO", track_change_flag = 0, tempPlayer = {}, tempMidi, bpm = 120;
var midi, json, tempMidi, tempJson;
var url, base_dir;
var map, track, stopTime = 0;
var buffer;
var filter_all_flag = 0, panner_all_flag = 0;

var fft_drums = new Tone.Analyser("fft", 32);
var fft_percs = new Tone.Analyser("fft", 32);
var fft_hats = new Tone.Analyser("fft", 32);
var fft_claps = new Tone.Analyser("fft", 32);
var fft_bass = new Tone.Analyser("fft", 32);
var fft_mids = new Tone.Analyser("fft", 32);
var fft_leads = new Tone.Analyser("fft", 32);
var fft_fx = new Tone.Analyser("fft", 32);

var waveform_drums = new Tone.Analyser("waveform", 1024);
var waveform_percs = new Tone.Analyser("waveform", 1024);
var waveform_hats = new Tone.Analyser("waveform", 1024);
var waveform_claps = new Tone.Analyser("waveform", 1024);
var waveform_bass = new Tone.Analyser("waveform", 1024);
var waveform_mids = new Tone.Analyser("waveform", 1024);
var waveform_leads = new Tone.Analyser("waveform", 1024);
var waveform_fx = new Tone.Analyser("waveform", 1024);

var baseVolumeMap = {
  '60': 0,
  '62': 0,
  '64': 0,
  '65': 0,
  '67': 0,
  '69': 0,
  '71': 0,
  '72': 0,
};

var volumeMap = {
  '60': 0,
  '62': 0,
  '64': 0,
  '65': 0,
  '67': 0,
  '69': 0,
  '71': 0,
  '72': 0,
};

  //comment this line for client
  getMubert({
    genre: "DUBTECHNO",
    bpm: "120",
    tone: "C",
    scale: "minor",
    app: "afp"
  });

  var limiter = new Tone.Limiter(-6).toMaster();
  var vol = new Tone.Volume(0).connect(limiter);    //change this to -24, -12 and 0
  var cheby = new Tone.Chebyshev(10).connect(vol);
  var comp = new Tone.Compressor(-30, 3).connect(cheby);
  var filter3 = new Tone.Filter(200, "highpass").connect(comp);
  var filter2 = new Tone.Filter(200, "highpass").connect(filter3);
  var filter1 = new Tone.Filter(200, "highpass").connect(filter2);

  var new_filter, filter_tracks;
  var panner;
  //var fft = new Tone.Analyser("fft", 32);;

		//get the waveform data for the audio
	var waveform = new Tone.Analyser("waveform", 1024);

  function getMubert(params){
    genre = params.genre;
    bpm = params.bpm;
    init();
  }

  function init(){
    addBuffering();
    getMidi();
    getNotes();
    removeBuffering();
  }

  function addFilter(filter_data){
    var filter_frequency = filter_data['frequency'];
    var filter_type = filter_data['type'];
    new_filter = new Tone.Filter(filter_frequency, filter_type);
    filter_tracks = filter_data['tracks'];
    if(filter_tracks.length > 0){
      for(var i=0; i<filter_tracks.length; i++){
        switch(track){
            case 'all': filter_all_flag = 1; break;

            default: player[filter_tracks[i]].connect(new_filter);
                      break;
        }
      }
    }
    if(filter_all_flag){
      for(str in baseVolumeMap){
        player[str].connect(new_filter);
      }
    }
  }

  function addStereoPan(panner_data){
      var panner_tracks = panner_data['tracks'];
      console.log(panner_tracks);
      var signal = panner_data['signal'];
      console.log(signal);
      panner = new Tone.Panner(signal);
      console.log(panner);
      if(panner_tracks.length > 0){
        for(var i=0; i<panner_tracks.length; i++){
          switch(panner_tracks[i]){
              case "all": panner_all_flag = 1; break;

              default: player[panner_tracks[i]].connect(panner);
                        break;
          }
        }
      }
      if(panner_all_flag){
        for(str in baseVolumeMap){
          player[str].connect(panner);
        }
      }
  }

  function setSchedule(){
    getTempMidi();
    getTempNotes();
    var interval = new Tone.Time("4m");
    var current = Tone.Transport.seconds;
    var newtime = current + interval.toSeconds();
    Tone.Transport.schedule(function(time){
        if(midiPart){
          midiPart.stop(time);
          player = tempPlayer;
          playMidi(midi);
          $('.item').removeClass("muted");
          $('.genre').removeClass("quadrat");
        }
      }, newtime);
  }

  function setVolumeMap(){
    for(str in player){
      if(str in volumeMap){
        player[str].volume.value = baseVolumeMap[str];
        player[str].mute = false;
      }
    }
    for(str in baseVolumeMap){
      volumeMap[str] = baseVolumeMap[str];
    }
  }

  function addBuffering(){
    $('#bufferContent').removeClass('hidden');
  }

  function removeBuffering(){
    $('#bufferContent').addClass('hidden');
  }

  function getMidi(){
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "https://pro.mubert.com/api", false);
    var params = '{"method":"Music", "params":[{"APP":"AFP"},{"BPM":"120.00"},{"TONE":"C"},{"SCALE":"MINOR"},{"GENRE":"' + genre + '"},{"MOOD":"ALL"}],"params_type":"title", "dt": "web", "app": "afp"}';
    xhr.send(params);
    json = JSON.parse(xhr.response);
    midi = json.data.midi;
  }

  function getNotes(){
    samples = json.data.samples;
    len = Object.keys(samples).length;
    var count = 0;
    for(sample in samples){
    player[sample] = new Tone.Player(samples[sample],
            function(){
              console.log(sample);
              count++;
              if(count == len){
                setVolumeMap();
                playMidi(midi);
                Tone.Transport.start(0);
                addFilter({
                   tracks: ['60', '62', '64'],
                   frequency: 200,
                   type: 'highpass'
                 }
                );
                addStereoPan({
                  tracks: ['all', '62', '64'],
                  signal: -1
                });
              }
            }
        );
    }
  }


  function getTempMidi(){
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "https://pro.mubert.com/api", false);
    var params = '{"method":"Music", "params":[{"APP":"AFP"},{"BPM":"120.00"},{"TONE":"C"},{"SCALE":"MINOR"},{"GENRE":"' + genre + '"},{"MOOD":"ALL"}],"params_type":"title", "dt": "web", "app": "afp"}';
    xhr.send(params);
    tempJson = JSON.parse(xhr.response);
    tempMidi = tempJson.data.midi;
  }

  function getTempNotes(){
    tempSamples = tempJson.data.samples;
    for(var sample in samples){
      tempPlayer[sample] = new Tone.Player({
                "url" : samples[sample],
                "loop" : false
        });
    }
  }

function changeTrack(){
  console.log('changeTrack');
  setSchedule();
}

function playMidi(file) {
  MidiConvert.load(file, function(midi) {
    // make sure you set the tempo before you schedule the events
    Tone.Transport.bpm.value = midi.header.bpm;
    midiPart = new Tone.Part(function(time, note) {
    console.log(time, note);
    var str = note.midi + '';

    if(str in player){
      //console.log(fft);

      switch(str){
        case '60': player[str].fan(fft_drums, waveform_drums).connect(cheby).start(time, 0, note.duration);
                    break;
        case '62': player[str].fan(fft_percs, waveform_percs).connect(cheby).start(time, 0, note.duration);
                    break;
        case '64': player[str].fan(fft_hats, waveform_hats).connect(cheby).start(time, 0, note.duration);
                    break;
        case '65': player[str].fan(fft_claps, waveform_claps).connect(cheby).start(time, 0, note.duration);
                    break;
        case '67': player[str].fan(fft_bass, waveform_bass).connect(cheby).start(time, 0, note.duration);
                    break;
        case '69': player[str].fan(fft_mids, waveform_mids).connect(cheby).start(time, 0, note.duration);
                    break;
        case '71': player[str].fan(fft_leads, waveform_leads).connect(cheby).start(time, 0, note.duration);
                    break;
        case '72': player[str].fan(fft_fx, waveform_fx).connect(cheby).start(time, 0, note.duration);
                    break;

      }

      if(str in volumeMap){
        player[str].volume.value = volumeMap[str];
      }
    }

  }, midi.tracks[0].notes).start(0);
     midiPart.loop = true;
     midiPart.loopEnd = midi.duration;
     Tone.Transport.bpm.value = bpm;
  });
}

//FFT and Waveform codes
//drawing the FFT
//var canvas = document.getElementById("canvasEl");
//var context = canvas.getContext('2d');


  $(document).ready(function(){
      $('.item').on('click', function(){
          var id = this.id;
          if($(this).hasClass("muted")){
            $(this).removeClass("muted");
            volumeMap[id] = 0;
            if(id in player){
              player[id].mute = false;
            }
          }
          else{
            $(this).addClass("muted");
            volumeMap[id] = -100;
            if(id in player){
              player[id].mute = true;
            }
          }
      });
      $('.genre').on('click', function(){
          var id = this.id;
          genre = id;
          $('.genre').removeClass("quadrat");
          $(this).addClass("quadrat");
          changeTrack();
      });
  });

  $(document).ready(function(){
    var fftContext_drums = document.getElementById("fft_drums").getContext("2d");
    var fftContext_percs = document.getElementById("fft_percs").getContext("2d");
    var fftContext_hats = document.getElementById("fft_hats").getContext("2d");
    var fftContext_claps = document.getElementById("fft_claps").getContext("2d");
    var fftContext_bass = document.getElementById("fft_bass").getContext("2d");
    var fftContext_mids = document.getElementById("fft_mids").getContext("2d");
    var fftContext_leads = document.getElementById("fft_leads").getContext("2d");
    var fftContext_fx = document.getElementById("fft_fx").getContext("2d");

		function drawFFT(fftContext, values){
			fftContext.clearRect(0, 0, canvasWidth, canvasHeight);
			var barWidth = canvasWidth / fft_drums.size;
			for (var i = 0, len = values.length; i < len; i++){
				var val = values[i] / 255;
				var x = canvasWidth * (i / len);
				var y = val * canvasHeight;
				fftContext.fillStyle = "rgba(0, 0, 0, " + val + ")";
				fftContext.fillRect(x, canvasHeight - y, barWidth, canvasHeight);
			}
		}
		//the waveform data
    var waveformContext_drums = document.getElementById("waveform_drums").getContext("2d");
    var waveformContext_percs = document.getElementById("waveform_percs").getContext("2d");
    var waveformContext_hats = document.getElementById("waveform_hats").getContext("2d");
    var waveformContext_claps = document.getElementById("waveform_claps").getContext("2d");
    var waveformContext_bass = document.getElementById("waveform_bass").getContext("2d");
    var waveformContext_mids = document.getElementById("waveform_mids").getContext("2d");
    var waveformContext_leads = document.getElementById("waveform_leads").getContext("2d");
    var waveformContext_fx = document.getElementById("waveform_fx").getContext("2d");
		var waveformGradient;
		function drawWaveform(waveContext, values){
			//draw the waveform
			waveContext.clearRect(0, 0, canvasWidth, canvasHeight);
			waveContext.beginPath();
			waveContext.lineJoin = "round";
			waveContext.lineWidth = 6;
			waveContext.strokeStyle = waveformGradient;
			waveContext.moveTo(0, (values[0] / 255) * canvasHeight);
			for (var i = 1, len = values.length; i < len; i++){
				var val = values[i] / 255;
				var x = canvasWidth * (i / len);
				var y = val * canvasHeight;
				waveContext.lineTo(x, y);
			}
			waveContext.stroke();
		}
		//size the canvases
		var canvasWidth, canvasHeight;
		function sizeCanvases(){
			canvasWidth = $("#fft_drums").width();
			canvasHeight = $("#fft_drums").height();
			//waveformContext_drums.canvas.width = canvasWidth;
			fftContext_drums.canvas.width = canvasWidth;
			//waveformContext_drums.canvas.height = canvasHeight;
			fftContext_drums.canvas.height = canvasHeight;
			//make the gradient
		  waveformGradient = waveformContext_drums.createLinearGradient(0, 0, canvasWidth, canvasHeight);
			waveformGradient.addColorStop(0, "#ddd");
			waveformGradient.addColorStop(1, "#000");
		}
		sizeCanvases();
		$(window).resize(sizeCanvases);
		function loop(){
      //var sample = '67';
      requestAnimationFrame(loop);
			//get the fft data and draw it
			var fftValues_drums = fft_drums.analyse();
      var fftValues_percs = fft_percs.analyse();
      var fftValues_hats = fft_hats.analyse();
      var fftValues_claps = fft_claps.analyse();
      var fftValues_bass = fft_bass.analyse();
      var fftValues_mids = fft_mids.analyse();
      var fftValues_leads = fft_leads.analyse();
      var fftValues_fx = fft_fx.analyse();
      drawFFT(fftContext_drums, fftValues_drums);
      drawFFT(fftContext_percs, fftValues_percs);
      drawFFT(fftContext_hats, fftValues_hats);
      drawFFT(fftContext_claps, fftValues_claps);
      drawFFT(fftContext_bass, fftValues_bass);
      drawFFT(fftContext_mids, fftValues_mids);
      drawFFT(fftContext_leads, fftValues_leads);
      drawFFT(fftContext_fx, fftValues_fx);
			//get the waveform valeus and draw it
      var waveformValues_drums = waveform_drums.analyse();
      var waveformValues_percs = waveform_percs.analyse();
      var waveformValues_hats = waveform_hats.analyse();
      var waveformValues_claps = waveform_claps.analyse();
      var waveformValues_bass = waveform_bass.analyse();
      var waveformValues_mids = waveform_mids.analyse();
      var waveformValues_leads = waveform_leads.analyse();
      var waveformValues_fx = waveform_fx.analyse();
			drawWaveform(waveformContext_drums, waveformValues_drums);
      drawWaveform(waveformContext_percs, waveformValues_percs);
      drawWaveform(waveformContext_hats, waveformValues_hats);
      drawWaveform(waveformContext_claps, waveformValues_claps);
      drawWaveform(waveformContext_bass, waveformValues_bass);
      drawWaveform(waveformContext_mids, waveformValues_mids);
      drawWaveform(waveformContext_leads, waveformValues_leads);
      drawWaveform(waveformContext_fx, waveformValues_fx);
		}
    loop();
  });
