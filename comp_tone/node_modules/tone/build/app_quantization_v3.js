var midiPart, notes_arr;
var player = {}, genre = "TECHNO", track_change_flag = 0, tempPlayer = {}, tempMidi, bpm = 120;
var midi, json, tempMidi, tempJson;
var url, base_dir;
var map, track, stopTime = 0;
var buffer;

var fft = {
  '60': new Tone.Analyser("fft", 32),
  '62': new Tone.Analyser("fft", 32),
  '64': new Tone.Analyser("fft", 32),
  '65': new Tone.Analyser("fft", 32),
  '67': new Tone.Analyser("fft", 32),
  '69': new Tone.Analyser("fft", 32),
  '71': new Tone.Analyser("fft", 32),
  '72': new Tone.Analyser("fft", 32),
}

var waveform = {
  '60': new Tone.Analyser("waveform", 1024),
  '62': new Tone.Analyser("waveform", 1024),
  '64': new Tone.Analyser("waveform", 1024),
  '65': new Tone.Analyser("waveform", 1024),
  '67': new Tone.Analyser("waveform", 1024),
  '69': new Tone.Analyser("waveform", 1024),
  '71': new Tone.Analyser("waveform", 1024),
  '72': new Tone.Analyser("waveform", 1024),
}

var baseVolumeMap = {
  '60': 0,
  '62': 0,
  '64': 0,
  '65': 0,
  '67': 0,
  '69': 0,
  '71': 0,
  '72': 0,
};

var volumeMap = {
  '60': 0,
  '62': 0,
  '64': 0,
  '65': 0,
  '67': 0,
  '69': 0,
  '71': 0,
  '72': 0,
};

  //comment this line for client
  getMubert({
    genre: "DUBTECHNO",
    bpm: "120",
    tone: "C",
    scale: "minor",
    app: "afp"
  });

  var limiter = new Tone.Limiter(-6).toMaster();
  var vol = new Tone.Volume(0).connect(limiter);    //change this to -24, -12 and 0
  var cheby = new Tone.Chebyshev(10).connect(vol);
  var comp = new Tone.Compressor(-30, 3).connect(cheby);
  var filter3 = new Tone.Filter(200, "highpass").connect(comp);
  var filter2 = new Tone.Filter(200, "highpass").connect(filter3);
  var filter1 = new Tone.Filter(200, "highpass").connect(filter2);

  //var fft = new Tone.Analyser("fft", 32);;

		//get the waveform data for the audio
	var waveform = new Tone.Analyser("waveform", 1024);

  function getMubert(params){
    genre = params.genre;
    bpm = params.bpm;
    init();
  }

  function init(){
    addBuffering();
    getMidi();
    getNotes();
    removeBuffering();
  }

  function setSchedule(){
    getTempMidi();
    getTempNotes();
    var ts="16m";
    var interval = new Tone.Time("4m");
    console.log(interval.toSeconds());
    var current = Tone.Transport.seconds;
    var newtime = current + interval.toSeconds();
    console.log(current);
    console.log(newtime);
    Tone.Transport.schedule(function(time){
        console.log('schedule');
        console.log(time);
        if(midiPart){
          midiPart.stop(time);
          player = tempPlayer;
          playMidi(midi);
          $('.item').removeClass("muted");
          $('.genre').removeClass("quadrat");
        }
      }, newtime);
  }

  function setVolumeMap(){
    for(str in player){
      if(str in volumeMap){
        player[str].volume.value = baseVolumeMap[str];
        player[str].mute = false;
      }
    }
    for(str in baseVolumeMap){
      volumeMap[str] = baseVolumeMap[str];
    }
  }

  function addBuffering(){
    $('#bufferContent').removeClass('hidden');
  }

  function removeBuffering(){
    $('#bufferContent').addClass('hidden');
  }

  function getMidi(){
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "https://pro.mubert.com/api", false);
    var params = '{"method":"Music", "params":[{"APP":"AFP"},{"BPM":"120.00"},{"TONE":"C"},{"SCALE":"MINOR"},{"GENRE":"' + genre + '"},{"MOOD":"ALL"}],"params_type":"title", "dt": "web", "app": "afp"}';
    xhr.send(params);
    json = JSON.parse(xhr.response);
    midi = json.data.midi;
  }

  function getNotes(){
    samples = json.data.samples;
    len = Object.keys(samples).length;
    var count = 0;
    for(sample in samples){
    player[sample] = new Tone.Player(samples[sample],
            function(){
              console.log(sample);
              count++;
              if(count == len){
                setVolumeMap();
                playMidi(midi);
                Tone.Transport.start(0);
              }
            }
        );
    }
  }


  function getTempMidi(){
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "https://pro.mubert.com/api", false);
    var params = '{"method":"Music", "params":[{"APP":"AFP"},{"BPM":"120.00"},{"TONE":"C"},{"SCALE":"MINOR"},{"GENRE":"' + genre + '"},{"MOOD":"ALL"}],"params_type":"title", "dt": "web", "app": "afp"}';
    xhr.send(params);
    tempJson = JSON.parse(xhr.response);
    tempMidi = tempJson.data.midi;
  }

  function getTempNotes(){
    tempSamples = tempJson.data.samples;
    for(var sample in samples){
      tempPlayer[sample] = new Tone.Player({
                "url" : samples[sample],
                "loop" : false
        });
    }
  }

function changeTrack(){
  console.log('changeTrack');
  setSchedule();
}

function playMidi(file) {
  MidiConvert.load(file, function(midi) {
    // make sure you set the tempo before you schedule the events
    Tone.Transport.bpm.value = midi.header.bpm;
    midiPart = new Tone.Part(function(time, note) {
    console.log(time, note);
    var str = note.midi + '';
    if(str in player){
      //console.log(fft);
      player[str].fan(fft[str], waveform[str]).connect(cheby).start(time, 0, note.duration);
      if(str in volumeMap){
        player[str].volume.value = volumeMap[str];
      }
    }

  }, midi.tracks[0].notes).start(0);
     midiPart.loop = true;
     midiPart.loopEnd = midi.duration;
     Tone.Transport.bpm.value = bpm;
  });
}

//FFT and Waveform codes
//drawing the FFT
//var canvas = document.getElementById("canvasEl");
//var context = canvas.getContext('2d');


  $(document).ready(function(){
      $('.item').on('click', function(){
          var id = this.id;
          if($(this).hasClass("muted")){
            $(this).removeClass("muted");
            volumeMap[id] = 0;
            if(id in player){
              player[id].mute = false;
            }
          }
          else{
            $(this).addClass("muted");
            volumeMap[id] = -100;
            if(id in player){
              player[id].mute = true;
            }
          }
      });
      $('.genre').on('click', function(){
          var id = this.id;
          genre = id;
          $('.genre').removeClass("quadrat");
          $(this).addClass("quadrat");
          changeTrack();
      });
  });

  $(document).ready(function(){
    var fftContext = document.getElementById("fft").getContext("2d");
		function drawFFT(values){
			fftContext.clearRect(0, 0, canvasWidth, canvasHeight);
			var barWidth = canvasWidth / fft.size;
			for (var i = 0, len = values.length; i < len; i++){
				var val = values[i] / 255;
				var x = canvasWidth * (i / len);
				var y = val * canvasHeight;
				fftContext.fillStyle = "rgba(0, 0, 0, " + val + ")";
				fftContext.fillRect(x, canvasHeight - y, barWidth, canvasHeight);
			}
		}
		//the waveform data
		var waveContext = document.getElementById("waveform").getContext("2d");
		var waveformGradient;
		function drawWaveform(values){
			//draw the waveform
			waveContext.clearRect(0, 0, canvasWidth, canvasHeight);
			var values = waveform.analyse();
			waveContext.beginPath();
			waveContext.lineJoin = "round";
			waveContext.lineWidth = 6;
			waveContext.strokeStyle = waveformGradient;
			waveContext.moveTo(0, (values[0] / 255) * canvasHeight);
			for (var i = 1, len = values.length; i < len; i++){
				var val = values[i] / 255;
				var x = canvasWidth * (i / len);
				var y = val * canvasHeight;
				waveContext.lineTo(x, y);
			}
			waveContext.stroke();
		}
		//size the canvases
		var canvasWidth, canvasHeight;
		function sizeCanvases(){
			canvasWidth = $("#fft").width();
			canvasHeight = $("#fft").height();
			waveContext.canvas.width = canvasWidth;
			fftContext.canvas.width = canvasWidth;
			waveContext.canvas.height = canvasHeight;
			fftContext.canvas.height = canvasHeight;
			//make the gradient
			waveformGradient = waveContext.createLinearGradient(0, 0, canvasWidth, canvasHeight);
			waveformGradient.addColorStop(0, "#ddd");
			waveformGradient.addColorStop(1, "#000");
		}
		sizeCanvases();
		$(window).resize(sizeCanvases);
		function loop(){
      var sample = '67';
      requestAnimationFrame(loop);
			//get the fft data and draw it
			var fftValues = fft[sample].analyse();
      console.log(fftValues);
			drawFFT(fftValues);
			//get the waveform valeus and draw it
			var waveformValues = waveform[sample].analyse();
			drawWaveform(waveformValues);
		}
    loop();
  });
