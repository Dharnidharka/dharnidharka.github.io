<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Norway Walkthrough</title>
  <style>
    body {
      margin: 0;
    }

    #c {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #c:focus {
      outline: none;
    }

    .loader {
      border: 16px solid #f3f3f3;
      /* Light grey */
      border-top: 16px solid #3498db;
      /* Blue */
      border-radius: 50%;
      width: 120px;
      height: 120px;
      animation: spin 2s linear infinite;
      /* z-index: 10; */
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #myProgress {
      position: absolute;
      top: 50%;
      width: 400px;
      left: 0;
      right: 0;
      margin: 0 auto;
      background-color: grey;
    }

    #myBar {
      width: 1%;
      height: 30px;
      background-color: green;
    }

    #defaultDepthmap {
      display: none;
    }
  </style>
</head>

<body>
  <div id="myProgress">
    <div id="myBar"></div>
  </div>
  <canvas id="c" tabindex="1"></canvas>
  <img data-src="./../res/default_depthmap.png" id="defaultDepthmap">

</body>
<script src="https://maps.googleapis.com/maps/api/js?libraries=places&key=AIzaSyB6UARVCUzMTt42FlGx-HRWlPPr2NJhzVM"
  type="text/javascript"></script>
<script src="js/util.js" type="text/javascript"></script>
<script src="js/lib/v3_epoly.js" type="text/javascript"></script>

<script type="module">

  import { getRoute } from './js/route.js';
  import { init } from './js/shared-orbitcontrols.js';

  let defaultDepthMap;
  let road;
  let panoData = [];
  let workerStarted = 0;
  let prevPanoId;
  let prevLocation;

  const worker = new Worker('js/offscreen.js', { type: 'module' });

  const mouseEventHandler = makeSendPropertiesHandler([
    'ctrlKey',
    'metaKey',
    'shiftKey',
    'button',
    'clientX',
    'clientY',
    'pageX',
    'pageY',
  ]);
  const wheelEventHandlerImpl = makeSendPropertiesHandler([
    'deltaX',
    'deltaY',
  ]);
  const keydownEventHandler = makeSendPropertiesHandler([
    'ctrlKey',
    'metaKey',
    'shiftKey',
    'keyCode',
  ]);

  function wheelEventHandler(event, sendFn) {
    event.preventDefault();
    wheelEventHandlerImpl(event, sendFn);
  }

  function preventDefaultHandler(event) {
    event.preventDefault();
  }

  function copyProperties(src, properties, dst) {
    for (const name of properties) {
      dst[name] = src[name];
    }
  }

  function makeSendPropertiesHandler(properties) {
    return function sendProperties(event, sendFn) {
      const data = { type: event.type };
      copyProperties(event, properties, data);
      sendFn(data);
    };
  }

  function touchEventHandler(event, sendFn) {
    const touches = [];
    const data = { type: event.type, touches };
    for (let i = 0; i < event.touches.length; ++i) {
      const touch = event.touches[i];
      touches.push({
        pageX: touch.pageX,
        pageY: touch.pageY,
      });
    }
    sendFn(data);
  }

  // The four arrow keys
  const orbitKeys = {
    '37': true,  // left
    '38': true,  // up
    '39': true,  // right
    '40': true,  // down
  };
  function filteredKeydownEventHandler(event, sendFn) {
    const { keyCode } = event;
    if (orbitKeys[keyCode]) {
      event.preventDefault();
      keydownEventHandler(event, sendFn);
    }
  }

  let nextProxyId = 0;
  class ElementProxy {
    constructor(element, worker, eventHandlers) {
      this.id = nextProxyId++;
      this.worker = worker;
      const sendEvent = (data) => {
        this.worker.postMessage({
          type: 'event',
          id: this.id,
          data,
        });
      };

      // register an id
      worker.postMessage({
        type: 'makeProxy',
        id: this.id,
      });
      sendSize();
      for (const [eventName, handler] of Object.entries(eventHandlers)) {
        element.addEventListener(eventName, function (event) {
          handler(event, sendEvent);
        });
      }

      function sendSize() {
        const rect = element.getBoundingClientRect();
        sendEvent({
          type: 'size',
          left: rect.left,
          top: rect.top,
          width: element.clientWidth,
          height: element.clientHeight,
        });
      }

      // really need to use ResizeObserver
      window.addEventListener('resize', sendSize);
    }
  }

  function move(len, total) {
    var width = (len / total) * 100;
    var elem = document.getElementById("myBar");
    elem.style.width = width + "%";
  }

  function startWorker(canvas, panoData) {
    canvas.focus();

    // console.log('213', canvas.getContext('webgl'));

    const offscreen = canvas.transferControlToOffscreen();

    let offscreenCanvas = new OffscreenCanvas(16, 16);
    console.log('218', offscreenCanvas.getContext('webgl', {
      xrCompatible: true
    }));

    let depthMap = document.getElementById('defaultDepthmap').getAttribute('data-src');
    // console.log(depthMap);
    // let depthCanvas = document.createElement('canvas');
    // let context = depthCanvas.getContext('2d');

    //set dimensions
    // depthCanvas.width = img.width;
    // depthCanvas.height = img.height;

    // const depthCanvasOffscreen = depthCanvas.transferControlToOffscreen();

    //apply the old canvas to the new one
    // context.drawImage(img, 0, 0);

    const eventHandlers = {
      contextmenu: preventDefaultHandler,
      mousedown: mouseEventHandler,
      mousemove: mouseEventHandler,
      mouseup: mouseEventHandler,
      touchstart: touchEventHandler,
      touchmove: touchEventHandler,
      touchend: touchEventHandler,
      wheel: wheelEventHandler,
      keydown: mouseEventHandler,
    };
    const proxy = new ElementProxy(canvas, worker, eventHandlers);
    worker.postMessage({
      type: 'start',
      canvas: offscreen,
      canvasId: proxy.id,
      panoData: panoData,
      depthMap: depthMap
    }, [offscreen]);

    console.log('using OffscreenCanvas');  /* eslint-disable-line no-console */
  }

  function startMainPage(canvas) {
    init({ canvas, inputElement: canvas });
    console.log('using regular canvas');  /* eslint-disable-line no-console */
  }

  const streetViewService = new google.maps.StreetViewService();


  function getStreetviewPanorama(i) {
    // console.log(streetViewService, path);
    // for (let i = 0; i < path.length; i++) {
    // console.log(path[i].lat(), path[i].lng());
    let location = road[i];
    let zoom = 2;
    streetViewService.getPanorama({ location: location, radius: 50, source: 'outdoor' }, function (result, status) {
      // console.log('233', result, status);
      if (status === google.maps.StreetViewStatus.OK) {
        // var h = google.maps.geometry.spherical.computeHeading(location, result.location.latLng);
        // const panoId = result.location.pano
        const options = {
          panoId: result.location.pano,
          copyright: result.copyright,
          crossOrigin: 'Anonymous',
          index: i,
          rotation: result.tiles.centerHeading * Math.PI / 180.0,
          lat: location.lat(),
          lng: location.lng(),
          takeDownUrl: result.takeDownUrl,
          tiles: result.tiles,
          zoom: zoom,
        }

        if (options.panoId !== prevPanoId) {
          if (i > 0) {
            var heading = google.maps.geometry.spherical.computeHeading(prevLocation, location);
            options.heading = heading * Math.PI / 180;
            panoData.push(options);
          }
          prevLocation = location;
        }

        prevPanoId = options.panoId;
        i++;
        if (i % 50 == 0 || i == road.length) {
          if (workerStarted == 0) {
            workerStarted = 1;
            main(panoData);
          } else {
            sendDataToWorker(panoData);
          }
          panoData = [];
          if (i !== road.length) getStreetviewPanorama(i);
        }
        else {
          getStreetviewPanorama(i);
          move(i, 50);
        }
      } else {
        console.log('300 status false');
        i++;
        getStreetviewPanorama(i);
      }
    });

  }

  function sendDataToWorker(panoData) {

    worker.postMessage({
      type: 'panoData',
      panoData: panoData,
    });

  }

  function main(panoData) {  /* eslint consistent-return: 0 */

    var elem = document.getElementById("myBar");
    elem.style.display = "none";
    const canvas = document.querySelector('#c');
    if (canvas.transferControlToOffscreen) {
      startWorker(canvas, panoData);
    } else {
      startMainPage(canvas);
    }
  }

  // var destination = '1 jhon F. kennedy st cambridge massachussets';
  // var origin = '52 jhon F. kennedy st cambridge massachussets';
  // var origin = '5700 Wolseley Avenue, Côte Saint-Luc, QC, Canada';
  // var destination = 'Quartier Cavendish, Cavendish Boulevard, Côte Saint-Luc, QC, Canada';
  var origin = 'Unnamed Road, 4335 Dirdal, Norway';
  // var destination = 'Fv45 3, 4335 Dirdal, Norway';
  var destination = 'Steinskog 3, 4335 Dirdal, Norway';
  var travelMode = 'BICYCLING';
  var request = {
    origin: origin,
    destination: destination,
    travelMode: travelMode, // May or may not have luck with street view this way
  };
  getRoute(request, function (path, pathArray) {
    road = path;
    getStreetviewPanorama(0);
  });

</script>

</html>